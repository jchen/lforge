% !TEX root = ../paper.tex
\newpage
\section*{Abstract}

We present \textsc{Lforge}, a novel tool that implements a translation of Forge, a specification language based on relational logic, into Lean 4, an interactive theorem prover with rich metaprogramming capabilities, as a domain-specific language (DSL). \textsc{Lforge} widens the scope of what is possible with a Forge specification. While Forge's automated reasoning backend is capable of generating finite examples or counterexamples, Lean's capability for manual theorem proving allows us to write general and unbounded conclusions for the same model specifications. This approach is a step in mitigating the choice paralysis and uncertainty that researchers face in selecting formal methods tools by constructing a unified workflow that combines the strengths of two vastly different formal methods systems. We also explore Lean 4's advanced syntax featuers that enable us to embed Forge as a first-class language feature within Lean. Ultimately, \textsc{Lforge} seeks to demonstrate the potential for specification portability across different tools, proposing a model for interoperability that could streamline the verification of complex systems and improve user experience in formal methods research. 

\newpage
\section*{Acknowledgements}

\newpage
\section*{Notation}
Throughout the paper, you might encounter some visual or symbolic notation that is specific to this project or specific to the semantics of Forge and/or Lean. These are noted here. 

``$\bowtie$'' denotes the relational join operator. If $x: A \to B$ is a relation and $y: B \to C$ is a relation, then $x\bowtie y$ produces the relation $A\to C$ merged on common values in the rightmost ($B$) column of $x$ and the leftmost ($B$) column of $y$. $x$ and $y$ can be of arbitrary arity, so long as their leftmost and rightmost columns respectively match. 

Code snippets and listings have been included in this paper to serve as examples, motivation, or to provide implementation details. Where they are included, the color of the code block denotes the source language and context. \todo{fix according to feedback}

\begin{leanimpl}
-- This is the code block for the Lean implementation of our translation
def forgeEnsureHasType (expectedType? : Option Expr) (e : Expr)
    (errorMsgHeader? : Option String := "Forge Type Error") 
    (f? : Option Expr := none) : TermElabM Expr := do
  let some expectedType := expectedType? | return e
  if (← isDefEq (← inferType e) expectedType) then
    return e
  else
    mkCoe expectedType e f? errorMsgHeader?
\end{leanimpl}
is an example of a Lean implementation code block. This denotes code from the implementation of the translation from Forge to Lean. This encompasses the parsing and elaboration of Forge syntax within Lean, and is most often the metaprogramming implementation of Forge in Lean. 

\begin{forge}
-- This is the code block for a snippet of a model specification in Forge
sig Node {
  neighbors : set Node
}
pred connected[a : Node, b : Node] {
  b in a.neighbors
}
\end{forge}
is an example of a Forge code block. This denotes examples of a model (or a snippet of a model) in Forge. 

\begin{lean}
-- This is the code block for the translated Lean equivalent of a Forge snippet
opaque Node : Type
opaque neighbors : Node → Node → Prop

def connected (a : Node) (b : Node) : Prop :=
  neighbors a b
\end{lean}
is an example of a Lean translation code block. This denotes examples of the translated version of a Forge model or snippet. This is oftentimes the translated Lean code that is emitted our of our program. 

\newpage