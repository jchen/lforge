% !TEX root = ../paper.tex

\section{Introduction}
Formal methods are increasingly being applied in industry. Domain-specific formal methods tools empower researchers to specify, model, analyze, and verify complex software and hardware systems that otherwise prove unfeasible to fully examine by hand \cite{abrial2006formal,lecomte2017applying}. These applications prove invaluable when the functionality of an existing system needs to be verified to be correct, or when new systems need to be synthesized based on a set of logical constraints and specifications \cite{woodcock2009formal}.

Yet, there is a multitude of tools and flavors that exist in the realm of formal methods: type-checked programming languages \cite{gao2017type,chaudhuri2017fast}, property-based testing frameworks \cite{fink1997property,maciver2019hypothesis}, modeling and specification languages \cite{jackson2012software,jackson2019alloy,ngpdbccdlrrvwwk-oopsla-2024}, SMT solvers \cite{de2008z3}, proof assistants \cite{moura2021lean}, etc. Each of these tools offers a tailored set of features and is based upon a specific yet different logical framework. An SMT solver based on the boolean satisfiability problem is different from a proof assistant which relies on dependent type theory. Due to operating under these diverse and different frameworks, few if any offer any form of interoperability---there is no common form of formal methods modeling or specification language. Each tool offers precisely what its framework allows. 

As a result, there arise limitations as to what \emph{can} and \emph{cannot} be modeled by specific techniques. In a survey of applications of formal methods within industry, the majority of respondents repeatedly identified that formal methods are useful in projects but similarly agreed that they felt tools were incapable or often ill-suited to the particular task at hand \cite{woodcock2009formal}. This problem of selecting tools is so prevalent that there have been surveys and methodologies devised for this task \cite{kossak2016select,cheng2006survey}. 

This paper introduces \textsc{Lforge}\footnote{Unfortunately the superior option amongst contenders \textsc{Flean}, \textsc{Fean}, and \textsc{Lorge}.}, a tool that implements the Forge specification language \cite{ngpdbccdlrrvwwk-oopsla-2024} (a pedagogical offshoot of Alloy \cite{jackson2012software}, which we use due to its gradually featured nature as well as simpler syntax) via a translation process as a language-level feature of Lean, an interactive proof assistant \cite{moura2021lean}.

In doing such, \textsc{Lforge} aims to be an example of interfacing between two drastically different tools in the larger realm of formal methods. The goal of this is to reduce the number of `make-or-break' choices that researchers face within the field and allow users to harness the resolving capabilities of multiple formal methods models, picking and choosing the features from multiple feature sets that are important to them. 

Forge and Lean work in fundamentally different ways. Forge, which is based on the Alloy relational model solver, uses the language of relational logic to specify and `solve' systems. A system is specified as a collection of \emph{signatures}, and model specifications are provided as a set of logical constraints on relations between signatures. Forge will then apply a SAT solver to the set of constraints to generate an \emph{instance} of the specified model (with some finite instances of each signature) \cite{jackson2019alloy,ngpdbccdlrrvwwk-oopsla-2024}. This makes Forge suited for generating finite examples or counterexamples to provided specifications. Lean, on the other hand, is an interactive theorem prover that is based on dependent type theory\footnote{Specifically, the \emph{calculus of (inductive) constructions}. This is the logical system first implemented in Coq \cite{bertot2008short}.} \cite{avigad2024theorem}. Systems are implemented within the functional programming language, and theorems containing logical statements about said systems can be stated and proven. Lean verifies that said proof is correct---and that the system has claimed properties.

While Forge can automatically reason (via solving for satisfying instances) about finite instances and can solve for model existence, Lean allows the user to make general claims about a system, at the cost of requiring manual proving. Lean can assist in generalizing statements made in Forge, while Forge can easily disprove incorrect Lean statements via counterexample\footnote{Lean will not indicate whether a statement is true or false.}. By allowing users to input Forge directly into a Lean source program, users can on one hand harness the automated reasoning tools that Forge provides, yet circumvent any bound limitations of Forge by proving theorems directly in Lean. \textsc{Lforge} recognizes the benefit of being able to interoperate between these two models for verifying systems can prove useful in checking real-world models, especially where a human translation between the two tools can be tedious and prone to errors. 

The implication of this work and further hope is that the model specification syntax of Forge/Alloy can become a universal and portable specification suitable for multiple tools based on multiple frameworks alike. While we do make compromises as to what is and isn't able to be brought over from Forge to Lean, \textsc{Lforge} is explicit and clear about those assumptions and what is left for the user to specify or supplement. The larger objective is for \textsc{Lforge} to serve as a model of what specification portability could look like across classes of formal methods tools, and what the user experience might be as specifications are being translated and utilized. 

\textsc{Lforge} builds on a long series of existing work implementing and embedding Alloy and similar specification languages into existing programming languages \cite{milicevic2010executable,milicevic2014alpha,korner2022embedding,malik2010translating,mikhailov2002approach}, theorem provers \cite{arkoudas2004integrating,st2023comparison,krings2018translation}. We propose a modern example of this protocol, first on user experience, and select our source and target language around these constraints. Forge is designed to be learnable and a simpler adaptation of Alloy \cite{ngpdbccdlrrvwwk-oopsla-2024}, and Lean provides an extensible \cite{nawrocki2023extensible,ullrich2023extensible} and usable \cite{ayers2021graphical} framework for theorem proving. 

\textsc{Lforge} serves as one of the first experimentations with Lean 4's complex and rich metaprogramming capabilities \cite{metaprogramming}, implementing Forge as a full-fledged DSL in Lean 4. At the same time, we harness Lean 4's out-of-the-box language server\footnote{What powers Lean 4's autocomplete, interactive theorem prover, tooltip-on-hover, etc. in VS Code.}, interactive capabilities \cite{nawrocki2023extensible}, and type unification system to suit Forge. The end product is a language experience that is definitely on par, if not more feature-rich than native Forge support in any IDEs from a purely user-experience perspective. 

The hope is that \textsc{Lforge} becomes a DSL that focuses on usability-first despite operating within the translation constraints imposed by formal frameworks. We hope for it to become a tool (or, at the very least, serve as a blueprint for a tool) that is an essential utility in any researcher's formal methods toolbox. 